#!/usr/bin/python3

from tf2_ros import *
from tf2_geometry_msgs import *
import rclpy
from rclpy.node import Node
from sensor_msgs.msg import LaserScan, PointCloud
from geometry_msgs.msg import Twist
from geometry_msgs.msg import Point32
from kobuki_ros_interfaces.msg import *

def infiniteTalk():
    # Initialize ROS node with ROS client
    rclpy.init()
    aNode = Node('basic_move')
    control = StraightCtrl(aNode)
    # Start infinite loop
    rclpy.spin(aNode)
    # Clean everything and switch the light off
    aNode.destroy_node()
    rclpy.shutdown()

class StraightCtrl:
    def __init__(self, node):
        self.rosNode = node
        # Transform tool:
        self.tf_buffer = tf2_ros.Buffer()
        self.tf_listener = tf2_ros.TransformListener(self.tf_buffer, self.rosNode)

        self.rosNode.create_subscription( PoseStamped, 'goal_pose', self.update_goal_pose, 10)

        self.nav_publisher= self.rosNode.create_publisher(Twist, '/multi/cmd_nav', 10 )

        # Node Attribute:
        self.local_frame= 'base_link'
        self.global_goal= Pose()
        self.global_goal.position.x= (float)(1)
        self.global_goal.position.y= (float)(2)

        self.LINEAR_SPEED = 0.4 #self.rosNode.get_parameter( 'linear_speed' ).value
        self.THRESHOLD_DIST = 0.4 #self.rosNode.get_parameter( 'threshold_dist' ).value
        self.ANGULAR_SPEED = 0.5 #self.rosNode.get_parameter( 'angular_speed' ).value
        self.LIMITE_ANGLE = 1.0 #self.rosNode.get_parameter( 'limite_angle' ).value
        self.ANGLE_STRAIGHT = 1.0
        self.straight_velocity = 0.0

        node.create_timer(0.1, self.publish_goal)

    def publish_goal(self):

        currentTime= rclpy.time.Time()
        # Get Transformation
        try:
            stampedTransform= self.tf_buffer.lookup_transform(
                        self.local_frame,
                        'odom',
                        currentTime)
        except (tf2_ros.LookupException, tf2_ros.ConnectivityException, tf2_ros.ExtrapolationException, tf2_ros.TransformException) as tex:
            self.rosNode.get_logger().info( f'Could not transform the goal into {self.local_frame}: {tex}')
            return
        
        # Compute goal into local coordinates
        localGoal = tf2_geometry_msgs.do_transform_pose( self.global_goal, stampedTransform )

        print(localGoal.position)


        velocity = Twist()

        self.straight_velocity = ramp(self.straight_velocity, self.LINEAR_SPEED, 0.0025)
        velocity.linear.x = 0.0
        velocity.linear.y = 0.0
        velocity.linear.z = 0.0

        velocity.angular.x = 0.0
        velocity.angular.y = 0.0
        velocity.angular.z = 0.0

        if localGoal.position.x < 0 : 
            velocity.angular.z = self.ANGULAR_SPEED

        elif localGoal.position.y < -self.ANGLE_STRAIGHT :
            velocity.angular.z = self.ANGULAR_SPEED

        elif self.ANGLE_STRAIGHT < localGoal.position.y :
            velocity.angular.z = -self.ANGULAR_SPEED

        elif localGoal.position.x > 0.03 :
            velocity.linear.x = 0.3

        self.straight_velocity = velocity.linear.x

        self.nav_publisher.publish(velocity)


    def update_goal_pose(self, odometry_msg):
        self.global_goal = odometry_msg.pose

def ramp(base, target, step):
    if base < target:
        return base+step
    elif base > target:
        return base-step
    else:
        return base

# Execute the function.
if __name__ == "__main__":
    infiniteTalk()


